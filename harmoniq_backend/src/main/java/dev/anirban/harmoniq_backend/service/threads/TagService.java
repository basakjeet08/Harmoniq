package dev.anirban.harmoniq_backend.service.threads;

import dev.anirban.harmoniq_backend.entity.threads.Tag;
import dev.anirban.harmoniq_backend.entity.threads.Thread;
import dev.anirban.harmoniq_backend.entity.user.User;
import dev.anirban.harmoniq_backend.repo.TagRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class TagService {

    // Injecting the required dependencies
    private final ChatClient tagChatClient;
    private final TagRepository tagRepo;
    private final InterestService interestService;

    // This function creates the new tags in the database
    private List<Tag> createTags(List<String> relevantTagString, User user) {
        // Creating the lookup table
        Map<String, Tag> lookupTable = fetchAllTags()
                .stream()
                .collect(Collectors.toMap(Tag::getName, tag -> tag));

        // These variables are storing the current saved tags and the new tags generated by the chatbot
        ArrayList<Tag> savedTags = new ArrayList<>();
        ArrayList<Tag> newTags = new ArrayList<>();

        // Resolving if the generated tags are new or already from stored ones
        relevantTagString.forEach(relevantTag -> {
            // Checking if the generated tag is already there
            if (lookupTable.containsKey(relevantTag))
                savedTags.add(lookupTable.get(relevantTag));
            else {
                Tag newTag = Tag
                        .builder()
                        .name(relevantTag)
                        .threadTags(new ArrayList<>())
                        .interests(new ArrayList<>())
                        .build();

                // Storing the new tags in the list to save at last
                newTags.add(newTag);
            }
        });

        if (!newTags.isEmpty())
            log.info("(|) - Creating new tag entries with names : {}", newTags.stream().map(Tag::getName).toList());

        // Adding the new tags to the stored tags and returning it back
        savedTags.addAll(tagRepo.saveAll(newTags));

        // Updating the user interests
        interestService.markPositiveInterest(savedTags, user);

        return savedTags;
    }

    // This function generates the String tags which are the most relevant for the given description
    private List<String> generateTagStrings(String description, String allTags) {
        log.info("(|) - Generation tags ...");

        // Prompt to generate the tag
        String prompt = "Generate the 3 most relevant tags from these tags :" + allTags + " for the " +
                "following thread description:" + description;

        // Generating the tags from the chatbot
        String response = tagChatClient
                .prompt()
                .user(prompt)
                .call()
                .content();

        // Returning the top 3 tags generated by the bot
        return response != null && !response.isBlank()
                ? Arrays.stream(response.split(","))
                .map(String::trim)
                .filter(tag -> !tag.isEmpty())
                .limit(3)
                .toList()
                : Collections.emptyList();
    }

    // This function returns the most relevant tag objects from the database
    @Transactional
    public List<Tag> getRelevantTags(Thread thread, User user) {
        // Fetching all the old tags
        String allTags = fetchAllTags()
                .stream()
                .map(Tag::getName)
                .toList()
                .toString();

        // Fetching the relevant string tags according to the description
        List<String> relevantTagString = generateTagStrings(thread.getDescription(), allTags);
        return createTags(relevantTagString, user);
    }

    // This function fetches all the tags from the database
    public List<Tag> fetchAllTags() {
        return tagRepo.findAll();
    }

    // This function deletes the unused tags automatically
    @Scheduled(fixedRate = 86400000)
    @Transactional
    public void deleteUnusedTags() {
        List<Tag> unusedTags = tagRepo.findByThreadTagsIsEmpty();

        // When there are unused tags we delete it
        log.info("(|) - Checking for unused tags and found {} unused tags to delete !!", unusedTags.size());
        if (!unusedTags.isEmpty()) {
            tagRepo.deleteAll(unusedTags);
        }
    }
}