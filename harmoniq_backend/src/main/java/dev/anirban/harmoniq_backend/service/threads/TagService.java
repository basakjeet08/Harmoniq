package dev.anirban.harmoniq_backend.service.threads;

import dev.anirban.harmoniq_backend.entity.threads.Tag;
import dev.anirban.harmoniq_backend.entity.threads.Thread;
import dev.anirban.harmoniq_backend.entity.user.User;
import dev.anirban.harmoniq_backend.repo.TagRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.ai.chat.client.ChatClient;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class TagService {

    // Injecting the required dependencies
    private final ChatClient tagChatClient;
    private final TagRepository tagRepo;
    private final InterestService interestService;

    // This function generates the String tags which are the most relevant for the given description
    public List<String> generateTags(String description, String allTags) {
        // Prompt to generate the tag
        String prompt = "Generate the 3 most relevant tags from these tags :" + allTags + " for the " +
                "following thread description:" + description;

        // Generating the tags from the chatbot
        String response = tagChatClient
                .prompt()
                .user(prompt)
                .call()
                .content();

        // Returning the top 3 tags generated by the bot
        return response != null && !response.isBlank()
                ? Arrays.stream(response.split(","))
                .map(String::trim)
                .filter(tag -> !tag.isEmpty())
                .limit(3)
                .toList()
                : Collections.emptyList();
    }

    // This function returns the most relevant tag objects from the database
    @Transactional
    public List<Tag> getRelevantTags(Thread thread, User user) {
        // Fetching all the old tags
        List<Tag> existingTags = fetchAllTags();

        // Merged tag names and the lookup variables
        StringBuffer mergedTagString = new StringBuffer();
        Map<String, Tag> tagLookupTable = new HashMap<>();

        // Merging the tag names and creating the lookup file for later
        existingTags.forEach(tag -> {
            mergedTagString.append(tag.getName()).append(",");

            // Putting item in the lookup table
            tagLookupTable.put(tag.getName(), tag);
        });

        // Removing the trailing comma ","
        if (!mergedTagString.isEmpty())
            mergedTagString.setLength(mergedTagString.length() - 1);

        // Fetching the relevant string tags according to the description
        List<String> relevantTagString = generateTags(thread.getDescription(), mergedTagString.toString());

        // These variables are storing the current saved tags and the new tags generated by the chatbot
        ArrayList<Tag> savedTags = new ArrayList<>();
        ArrayList<Tag> newTags = new ArrayList<>();

        // Resolving if the generated tags are new or already from stored ones
        relevantTagString.forEach(relevantTag -> {

            // Checking if the generated tag is already there
            if (tagLookupTable.containsKey(relevantTag))
                savedTags.add(tagLookupTable.get(relevantTag));
            else
                newTags.add(Tag.builder()
                        .name(relevantTag)
                        .threadTags(new ArrayList<>())
                        .interests(new HashSet<>())
                        .build()
                );
        });

        // Adding the new tags to the stored tags and returning it back
        savedTags.addAll(tagRepo.saveAll(newTags));

        // Updating the user interests
        interestService.markPositiveInterest(savedTags, user);
        return savedTags;
    }

    // This function fetches all the tags from the database
    public List<Tag> fetchAllTags() {
        return tagRepo.findAll();
    }

    // This function fetches tags by their Name
    public List<Tag> findByNameContainingIgnoreCase(String name) {
        return tagRepo.findByNameContainingIgnoreCase(name);
    }

    // This function deletes the unused tags automatically
    @Scheduled(fixedRate = 86400000)
    @Transactional
    public void deleteUnusedTags() {
        List<Tag> unusedTags = fetchAllTags()
                .stream()
                .filter(tag -> tag.getThreadTags() == null || tag.getThreadTags().isEmpty())
                .toList();

        // When there are unused tags we delete it
        log.info("(|) - Checking for unused tags and found {} unused tags to delete !!", unusedTags.size());
        if (!unusedTags.isEmpty()) {
            tagRepo.deleteAll(unusedTags);
        }
    }
}